module Infer.ExplicitSubstitution.Substitution where

import Data.Coerce
import Data.Map (Map)
import Data.Map qualified as Map
import Data.Set (Set)
import Data.Set qualified as Set
import Data.Text (Text)
import Data.Text qualified as T
import Infer.Syntax
import Infer.TypeEnv

newtype Substitution
  = Substitution (Map Identifier Type)
  deriving (Show)

delete :: Identifier -> Substitution -> Substitution
delete = coerce (Map.delete @_ @Type)

singleton :: Identifier -> Type -> Substitution
singleton = coerce (Map.singleton @_ @Type)

findWithDefault :: Type -> Identifier -> Substitution -> Type
findWithDefault = coerce (Map.findWithDefault @_ @Type)

fromList :: [(Identifier, Type)] -> Substitution
fromList = coerce (Map.fromList @_ @Type)

instance Semigroup Substitution where
  (<>) :: Substitution -> Substitution -> Substitution
  s1@(Substitution s1') <> Substitution s2 =
    Substitution (fmap (apply s1) s2 <> s1')

instance Monoid Substitution where
  mempty :: Substitution
  mempty = Substitution Map.empty

class Substitutable a where
  freeVars :: a -> Set Identifier
  apply :: Substitution -> a -> a

instance Substitutable Type where
  freeVars :: Type -> Set Identifier
  freeVars = \case
    TBoolean -> Set.empty
    TInteger -> Set.empty
    TVariable var -> Set.singleton var
    TArrow input output ->
      freeVars input <> freeVars output

  apply :: Substitution -> Type -> Type
  apply substitution = \case
    TBoolean -> TBoolean
    TInteger -> TInteger
    tVar@(TVariable var) ->
      findWithDefault tVar var substitution
    TArrow input output ->
      TArrow
        (apply substitution input)
        (apply substitution output)

instance Substitutable Scheme where
  freeVars :: Scheme -> Set Identifier
  freeVars (Scheme ids tpe) =
    Set.difference (Set.fromList ids) (freeVars tpe)

  apply :: Substitution -> Scheme -> Scheme
  apply substitution (Scheme ids tpe) =
    -- I think if implementation is right, there is no require the deletion.
    -- Because the type variables in type environment are all generated uniquely and start with '$',
    -- and type variables in type scheme are either provided by signatures which won't start with '$',
    -- or generated by generalization which should not appear in substitution.
    -- The generated type variables in type scheme need an instantiation to appear in substitution.
    -- But regardless of whether the type variables in environment and scheme intersect,
    -- the deletion won't cause any new problems, so it is safe to delete them.
    Scheme ids (apply (foldr delete substitution ids) tpe)

instance Substitutable TypeEnv where
  freeVars :: TypeEnv -> Set Identifier
  freeVars (TypeEnv env) = foldr ((<>) . freeVars) Set.empty env

  apply :: Substitution -> TypeEnv -> TypeEnv
  apply substitution (TypeEnv env) = TypeEnv (apply substitution <$> env)
